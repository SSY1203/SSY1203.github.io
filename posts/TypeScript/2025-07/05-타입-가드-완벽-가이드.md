---
title: "TypeScript 타입 가드 완벽 가이드"
date: "2025-07-05"
category: "TypeScript"
excerpt: "런타임에서 타입을 안전하게 체크하는 방법들을 살펴보자. 사용자 정의 타입 가드부터 내장 타입 가드까지 다양한 패턴을 다룬다."
tags: ["TypeScript", "타입가드", "타입안전성", "런타임"]
---

# TypeScript 타입 가드 완벽 가이드

TypeScript에서 타입 가드(Type Guard)는 런타임에서 타입을 안전하게 체크하는 메커니즘이다. 컴파일 타임의 타입 정보를 런타임에서도 활용할 수 있게 해준다.

## 타입 가드가 필요한 이유

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

interface Admin {
  id: number;
  name: string;
  permissions: string[];
}

type Person = User | Admin;

function handlePerson(person: Person) {
  // ❌ 이렇게 하면 에러 발생
  console.log(person.email); // Property 'email' does not exist on type 'Person'
  
  // ✅ 타입 가드로 해결
  if ('email' in person) {
    console.log(person.email); // 이제 안전하게 접근 가능
  }
}
```

## 내장 타입 가드들

### 1. typeof 연산자

```typescript
function processValue(value: string | number) {
  if (typeof value === 'string') {
    // 이 블록에서 value는 string 타입
    return value.toUpperCase();
  } else {
    // 이 블록에서 value는 number 타입
    return value.toFixed(2);
  }
}
```

### 2. instanceof 연산자

```typescript
class Dog {
  bark() {
    console.log('Woof!');
  }
}

class Cat {
  meow() {
    console.log('Meow!');
  }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark(); // Dog 타입으로 좁혀짐
  } else {
    animal.meow(); // Cat 타입으로 좁혀짐
  }
}
```

### 3. in 연산자

```typescript
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function move(animal: Bird | Fish) {
  if ('fly' in animal) {
    animal.fly(); // Bird 타입
  } else {
    animal.swim(); // Fish 타입
  }
}
```

## 사용자 정의 타입 가드

가장 강력한 기능은 사용자 정의 타입 가드다.

### 기본 패턴

```typescript
function isUser(person: Person): person is User {
  return 'email' in person;
}

function isAdmin(person: Person): person is Admin {
  return 'permissions' in person;
}

function handlePerson(person: Person) {
  if (isUser(person)) {
    console.log(person.email); // User 타입으로 좁혀짐
  } else if (isAdmin(person)) {
    console.log(person.permissions); // Admin 타입으로 좁혀짐
  }
}
```

### 더 복잡한 예시

```typescript
interface ApiSuccess<T> {
  success: true;
  data: T;
}

interface ApiError {
  success: false;
  error: string;
}

type ApiResponse<T> = ApiSuccess<T> | ApiError;

// 타입 가드 함수
function isApiSuccess<T>(response: ApiResponse<T>): response is ApiSuccess<T> {
  return response.success === true;
}

// 사용
async function fetchUser(id: number): Promise<User | null> {
  const response: ApiResponse<User> = await api.getUser(id);
  
  if (isApiSuccess(response)) {
    return response.data; // ApiSuccess<User> 타입
  } else {
    console.error(response.error); // ApiError 타입
    return null;
  }
}
```

## 배열과 타입 가드

배열에서 특정 타입만 필터링할 때도 유용하다.

```typescript
const mixedArray: (string | number | null)[] = [
  'hello', 
  42, 
  null, 
  'world', 
  undefined, 
  123
];

// null과 undefined 제거
function isNotNullish<T>(value: T | null | undefined): value is T {
  return value !== null && value !== undefined;
}

const validValues = mixedArray.filter(isNotNullish);
// validValues의 타입: (string | number)[]

// 특정 타입만 추출
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

const strings = mixedArray.filter(isString);
// strings의 타입: string[]
```

## 고급 패턴

### 1. 조건부 타입과 함께 사용

```typescript
type NonNullable<T> = T extends null | undefined ? never : T;

function isNonNullable<T>(value: T): value is NonNullable<T> {
  return value !== null && value !== undefined;
}
```

### 2. 제네릭 타입 가드

```typescript
function isArrayOf<T>(
  array: unknown[], 
  guard: (item: unknown) => item is T
): array is T[] {
  return array.every(guard);
}

// 사용 예시
const maybeNumbers: unknown[] = [1, 2, 3, '4', 5];

function isNumber(value: unknown): value is number {
  return typeof value === 'number';
}

if (isArrayOf(maybeNumbers, isNumber)) {
  // maybeNumbers는 number[] 타입
  console.log(maybeNumbers.map(n => n * 2));
}
```

### 3. 객체 형태 검증

```typescript
function hasProperty<T extends object, K extends PropertyKey>(
  obj: T,
  key: K
): obj is T & Record<K, unknown> {
  return key in obj;
}

function isValidUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    hasProperty(obj, 'id') &&
    hasProperty(obj, 'name') &&
    hasProperty(obj, 'email') &&
    typeof obj.id === 'number' &&
    typeof obj.name === 'string' &&
    typeof obj.email === 'string'
  );
}
```

## 실전 활용 예시

### API 응답 처리

```typescript
interface UserData {
  id: number;
  name: string;
  email: string;
}

function isValidUserData(data: unknown): data is UserData {
  return (
    typeof data === 'object' &&
    data !== null &&
    typeof (data as any).id === 'number' &&
    typeof (data as any).name === 'string' &&
    typeof (data as any).email === 'string'
  );
}

async function fetchUserSafely(id: number): Promise<UserData | null> {
  try {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    
    if (isValidUserData(data)) {
      return data; // 타입 안전하게 반환
    } else {
      console.error('Invalid user data received');
      return null;
    }
  } catch (error) {
    console.error('Failed to fetch user:', error);
    return null;
  }
}
```

### 폼 검증

```typescript
interface FormData {
  username: string;
  email: string;
  age: number;
}

function isValidFormData(data: any): data is FormData {
  return (
    typeof data.username === 'string' &&
    data.username.length > 0 &&
    typeof data.email === 'string' &&
    data.email.includes('@') &&
    typeof data.age === 'number' &&
    data.age > 0
  );
}

function handleFormSubmit(formData: unknown) {
  if (isValidFormData(formData)) {
    // formData는 FormData 타입으로 좁혀짐
    submitToServer(formData);
  } else {
    showError('Invalid form data');
  }
}
```

## 주의사항과 베스트 프랙티스

### 1. 런타임 비용

타입 가드는 런타임에 실행되므로 성능을 고려해야 한다.

```typescript
// ❌ 무거운 검증
function isValidUser(obj: unknown): obj is User {
  // 복잡한 검증 로직...
  return expensiveValidation(obj);
}

// ✅ 빠른 검증 우선
function isValidUser(obj: unknown): obj is User {
  // 빠른 검증 먼저
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }
  
  // 필요한 경우에만 세밀한 검증
  return detailedValidation(obj);
}
```

### 2. 타입 안전성 보장

```typescript
// ❌ 불안전한 타입 가드
function isUser(obj: any): obj is User {
  return obj.id !== undefined; // 너무 느슨한 검증
}

// ✅ 안전한 타입 가드
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof (obj as any).id === 'number' &&
    typeof (obj as any).name === 'string' &&
    typeof (obj as any).email === 'string'
  );
}
```

## 마무리

타입 가드는 TypeScript의 타입 시스템을 런타임까지 확장하는 강력한 도구다. 적절히 활용하면:

1. **런타임 안전성** 확보
2. **API 응답 검증** 자동화
3. **코드 가독성** 향상
4. **타입 추론** 개선

복잡한 데이터 처리나 외부 API 연동 시 타입 가드를 적극 활용해보자!